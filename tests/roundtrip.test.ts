/**
 * Round-trip tests that validate interoperability with Rust's rkyv.
 *
 * These tests:
 * 1. Read binary fixtures generated by Rust
 * 2. Decode them using rkyv-js
 * 3. Re-encode them using rkyv-js
 * 4. Write the re-encoded bytes for Rust validation
 *
 * Run the full round-trip test with: npm run test:roundtrip
 */

import * as assert from 'node:assert';
import { describe, it } from 'node:test';
import { readFileSync } from 'node:fs';
import * as path from 'node:path';

import { r } from 'rkyv-js';
import {
  ArchivedPoint,
  ArchivedPerson,
  ArchivedMessage,
  ArchivedGameState,
} from 'rkyv-example';

const FIXTURES_DIR = path.join(import.meta.dirname, '../rkyv-example/fixtures');

function readFixture(name: string): Uint8Array {
  const file = path.join(FIXTURES_DIR, `${name}.bin`);
  return new Uint8Array(readFileSync(file));
}

describe('Round-trip tests with Rust rkyv', () => {
  describe('Point', () => {
    it('should decode and re-encode point', () => {
      const bytes = readFixture('point');
      const point = r.decode(ArchivedPoint, bytes);

      assert.strictEqual(point.x, 42.5);
      assert.strictEqual(point.y, -17.25);

      // Re-encode
      const reencoded = r.encode(ArchivedPoint, point);


      // Verify we can decode our own encoding
      const decoded2 = r.decode(ArchivedPoint, reencoded);
      assert.strictEqual(decoded2.x, point.x);
      assert.strictEqual(decoded2.y, point.y);
    });
  });

  describe('Person', () => {
    it('should decode and re-encode person with all fields', () => {
      const bytes = readFixture('person');
      const person = r.decode(ArchivedPerson, bytes);

      assert.strictEqual(person.name, 'Alice');
      assert.strictEqual(person.age, 30);
      assert.strictEqual(person.email, 'alice@example.com');
      assert.deepStrictEqual(person.scores, [100, 95, 87, 92]);
      assert.strictEqual(person.active, true);

      // Re-encode
      const reencoded = r.encode(ArchivedPerson, person);


      // Verify
      const decoded2 = r.decode(ArchivedPerson, reencoded);
      assert.deepStrictEqual(decoded2, person);
    });

    it('should decode and re-encode person with null email', () => {
      const bytes = readFixture('person_no_email');
      const person = r.decode(ArchivedPerson, bytes);

      assert.strictEqual(person.name, 'Bob');
      assert.strictEqual(person.age, 25);
      assert.strictEqual(person.email, null);
      assert.deepStrictEqual(person.scores, []);
      assert.strictEqual(person.active, false);

      // Re-encode
      const reencoded = r.encode(ArchivedPerson, person);


      // Verify
      const decoded2 = r.decode(ArchivedPerson, reencoded);
      assert.deepStrictEqual(decoded2, person);
    });
  });

  describe('Message enum', () => {
    it('should decode and re-encode Quit variant', () => {
      const bytes = readFixture('message_quit');
      const msg = r.decode(ArchivedMessage, bytes);

      assert.strictEqual(msg.tag, 'Quit');
      assert.strictEqual(msg.value, null);

      const reencoded = r.encode(ArchivedMessage, msg);

      const decoded2 = r.decode(ArchivedMessage, reencoded);
      assert.strictEqual(decoded2.tag, 'Quit');
    });

    it('should decode and re-encode Move variant', () => {
      const bytes = readFixture('message_move');
      const msg = r.decode(ArchivedMessage, bytes);

      assert.strictEqual(msg.tag, 'Move');
      assert.deepStrictEqual(msg.value, { x: 10, y: -20 });

      const reencoded = r.encode(ArchivedMessage, msg);


      const decoded2 = r.decode(ArchivedMessage, reencoded);
      assert.deepStrictEqual(decoded2, msg);
    });

    it('should decode and re-encode Write variant', () => {
      const bytes = readFixture('message_write');
      const msg = r.decode(ArchivedMessage, bytes);

      assert.strictEqual(msg.tag, 'Write');
      assert.deepStrictEqual(msg.value, { _0: 'Hello, World!' });

      const reencoded = r.encode(ArchivedMessage, msg);

      const decoded2 = r.decode(ArchivedMessage, reencoded);
      assert.deepStrictEqual(decoded2, msg);
    });

    it('should decode and re-encode ChangeColor variant', () => {
      const bytes = readFixture('message_color');
      const msg = r.decode(ArchivedMessage, bytes);

      assert.strictEqual(msg.tag, 'ChangeColor');
      assert.deepStrictEqual(msg.value, { _0: 255, _1: 128, _2: 0 });

      const reencoded = r.encode(ArchivedMessage, msg);

      const decoded2 = r.decode(ArchivedMessage, reencoded);
      assert.deepStrictEqual(decoded2, msg);
    });
  });

  describe('GameState (nested)', () => {
    it('should decode and re-encode complex game state', () => {
      const bytes = readFixture('game_state');
      const state = r.decode(ArchivedGameState, bytes);

      assert.strictEqual(state.player_position.x, 100.0);
      assert.strictEqual(state.player_position.y, 200.0);
      assert.strictEqual(state.health, 85);
      assert.deepStrictEqual(state.inventory, ['sword', 'shield', 'potion']);
      assert.notStrictEqual(state.current_message, null);
      assert.strictEqual(state.current_message?.tag, 'Write');

      const reencoded = r.encode(ArchivedGameState, state);

      const decoded2 = r.decode(ArchivedGameState, reencoded);
      assert.deepStrictEqual(decoded2.player_position, state.player_position);
      assert.strictEqual(decoded2.health, state.health);
      assert.deepStrictEqual(decoded2.inventory, state.inventory);
    });

    it('should decode and re-encode simple game state', () => {
      const bytes = readFixture('game_state_simple');
      const state = r.decode(ArchivedGameState, bytes);

      assert.strictEqual(state.player_position.x, 0.0);
      assert.strictEqual(state.player_position.y, 0.0);
      assert.strictEqual(state.health, 100);
      assert.deepStrictEqual(state.inventory, []);
      assert.strictEqual(state.current_message, null);

      const reencoded = r.encode(ArchivedGameState, state);

      const decoded2 = r.decode(ArchivedGameState, reencoded);
      assert.deepStrictEqual(decoded2, state);
    });
  });
});
