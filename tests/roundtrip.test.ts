/**
 * Round-trip tests that validate interoperability with Rust's rkyv.
 *
 * These tests:
 * 1. Read binary fixtures generated by Rust
 * 2. Decode them using rkyv-js
 * 3. Re-encode them using rkyv-js
 * 4. Write the re-encoded bytes for Rust validation
 *
 * Run the full round-trip test with: npm run test:roundtrip
 */

import { describe, it, expect } from 'vitest';
import { readFileSync } from 'fs';
import { join } from 'path';
import { r } from '../src/index.js';

import {
  ArchivedPoint,
  ArchivedPerson,
  ArchivedMessage,
  ArchivedGameState,
  type Point,
  type Person,
  type Message,
  type GameState,
} from 'rkyv-example';

const FIXTURES_DIR = join(__dirname, '../rkyv-example/fixtures');

function readFixture(name: string): Uint8Array {
  const path = join(FIXTURES_DIR, `${name}.bin`);
  return new Uint8Array(readFileSync(path));
}

describe('Round-trip tests with Rust rkyv', () => {

  describe('Point', () => {
    it('should decode and re-encode point', () => {
      const bytes = readFixture('point');
      const point = r.decode(ArchivedPoint, bytes);

      expect(point.x).toBe(42.5);
      expect(point.y).toBe(-17.25);

      // Re-encode
      const reencoded = r.encode(ArchivedPoint, point);


      // Verify we can decode our own encoding
      const decoded2 = r.decode(ArchivedPoint, reencoded);
      expect(decoded2.x).toBe(point.x);
      expect(decoded2.y).toBe(point.y);
    });
  });

  describe('Person', () => {
    it('should decode and re-encode person with all fields', () => {
      const bytes = readFixture('person');
      const person = r.decode(ArchivedPerson, bytes);

      expect(person.name).toBe('Alice');
      expect(person.age).toBe(30);
      expect(person.email).toBe('alice@example.com');
      expect(person.scores).toEqual([100, 95, 87, 92]);
      expect(person.active).toBe(true);

      // Re-encode
      const reencoded = r.encode(ArchivedPerson, person);


      // Verify
      const decoded2 = r.decode(ArchivedPerson, reencoded);
      expect(decoded2).toEqual(person);
    });

    it('should decode and re-encode person with null email', () => {
      const bytes = readFixture('person_no_email');
      const person = r.decode(ArchivedPerson, bytes);

      expect(person.name).toBe('Bob');
      expect(person.age).toBe(25);
      expect(person.email).toBeNull();
      expect(person.scores).toEqual([]);
      expect(person.active).toBe(false);

      // Re-encode
      const reencoded = r.encode(ArchivedPerson, person);


      // Verify
      const decoded2 = r.decode(ArchivedPerson, reencoded);
      expect(decoded2).toEqual(person);
    });
  });

  describe('Message enum', () => {
    it('should decode and re-encode Quit variant', () => {
      const bytes = readFixture('message_quit');
      const msg = r.decode(ArchivedMessage, bytes);

      expect(msg.tag).toBe('Quit');
      expect(msg.value).toBeUndefined();

      const reencoded = r.encode(ArchivedMessage, msg);


      const decoded2 = r.decode(ArchivedMessage, reencoded);
      expect(decoded2.tag).toBe('Quit');
    });

    it('should decode and re-encode Move variant', () => {
      const bytes = readFixture('message_move');
      const msg = r.decode(ArchivedMessage, bytes);

      expect(msg.tag).toBe('Move');
      expect(msg.value).toEqual({ x: 10, y: -20 });

      const reencoded = r.encode(ArchivedMessage, msg);


      const decoded2 = r.decode(ArchivedMessage, reencoded);
      expect(decoded2).toEqual(msg);
    });

    it('should decode and re-encode Write variant', () => {
      const bytes = readFixture('message_write');
      const msg = r.decode(ArchivedMessage, bytes);

      expect(msg.tag).toBe('Write');
      expect(msg.value).toEqual({ _0: 'Hello, World!' });

      const reencoded = r.encode(ArchivedMessage, msg);


      const decoded2 = r.decode(ArchivedMessage, reencoded);
      expect(decoded2).toEqual(msg);
    });

    it('should decode and re-encode ChangeColor variant', () => {
      const bytes = readFixture('message_color');
      const msg = r.decode(ArchivedMessage, bytes);

      expect(msg.tag).toBe('ChangeColor');
      expect(msg.value).toEqual({ _0: 255, _1: 128, _2: 0 });

      const reencoded = r.encode(ArchivedMessage, msg);


      const decoded2 = r.decode(ArchivedMessage, reencoded);
      expect(decoded2).toEqual(msg);
    });
  });

  describe('GameState (nested)', () => {
    it('should decode and re-encode complex game state', () => {
      const bytes = readFixture('game_state');
      const state = r.decode(ArchivedGameState, bytes);

      expect(state.player_position.x).toBe(100.0);
      expect(state.player_position.y).toBe(200.0);
      expect(state.health).toBe(85);
      expect(state.inventory).toEqual(['sword', 'shield', 'potion']);
      expect(state.current_message).not.toBeNull();
      expect(state.current_message?.tag).toBe('Write');

      const reencoded = r.encode(ArchivedGameState, state);


      const decoded2 = r.decode(ArchivedGameState, reencoded);
      expect(decoded2.player_position).toEqual(state.player_position);
      expect(decoded2.health).toBe(state.health);
      expect(decoded2.inventory).toEqual(state.inventory);
    });

    it('should decode and re-encode simple game state', () => {
      const bytes = readFixture('game_state_simple');
      const state = r.decode(ArchivedGameState, bytes);

      expect(state.player_position.x).toBe(0.0);
      expect(state.player_position.y).toBe(0.0);
      expect(state.health).toBe(100);
      expect(state.inventory).toEqual([]);
      expect(state.current_message).toBeNull();

      const reencoded = r.encode(ArchivedGameState, state);


      const decoded2 = r.decode(ArchivedGameState, reencoded);
      expect(decoded2).toEqual(state);
    });
  });
});
