//! TypeScript code generator for rkyv types.

use crate::types::{EnumVariant, TypeDef, UnionVariant};
use std::collections::{BTreeMap, HashMap, HashSet};
use std::fs;
use std::io::{self, Write};
use std::path::Path;

/// Code generator that collects type definitions and outputs TypeScript code.
#[derive(Debug, Default)]
pub struct CodeGenerator {
    /// Struct definitions: name -> fields
    structs: BTreeMap<String, Vec<(String, TypeDef)>>,

    /// Enum definitions: name -> variants
    enums: BTreeMap<String, Vec<EnumVariant>>,

    /// Union definitions: name -> variants
    unions: BTreeMap<String, Vec<UnionVariant>>,

    /// Type aliases: alias_name -> target_type
    aliases: BTreeMap<String, TypeDef>,

    /// Custom header comment
    header: Option<String>,
}

impl CodeGenerator {
    /// Create a new code generator.
    pub fn new() -> Self {
        Self::default()
    }

    /// Set a custom header comment for the generated file.
    pub fn set_header(&mut self, header: impl Into<String>) -> &mut Self {
        self.header = Some(header.into());
        self
    }

    /// Add a struct definition.
    ///
    /// # Example
    ///
    /// ```
    /// use rkyv_js_codegen::{CodeGenerator, TypeDef};
    ///
    /// let mut gen = CodeGenerator::new();
    /// gen.add_struct("Point", &[
    ///     ("x", TypeDef::F64),
    ///     ("y", TypeDef::F64),
    /// ]);
    /// ```
    pub fn add_struct(
        &mut self,
        name: impl Into<String>,
        fields: &[(impl AsRef<str>, TypeDef)],
    ) -> &mut Self {
        let fields: Vec<_> = fields
            .iter()
            .map(|(n, t)| (n.as_ref().to_string(), t.clone()))
            .collect();
        self.structs.insert(name.into(), fields);
        self
    }

    /// Add an enum definition.
    ///
    /// # Example
    ///
    /// ```
    /// use rkyv_js_codegen::{CodeGenerator, TypeDef, EnumVariant};
    ///
    /// let mut gen = CodeGenerator::new();
    /// gen.add_enum("Status", &[
    ///     EnumVariant::Unit("Pending".to_string()),
    ///     EnumVariant::Unit("Active".to_string()),
    ///     EnumVariant::Struct("Error".to_string(), vec![
    ///         ("message".to_string(), TypeDef::String),
    ///     ]),
    /// ]);
    /// ```
    pub fn add_enum(&mut self, name: impl Into<String>, variants: &[EnumVariant]) -> &mut Self {
        self.enums.insert(name.into(), variants.to_vec());
        self
    }

    /// Add a type alias (newtype pattern).
    pub fn add_alias(&mut self, name: impl Into<String>, target: TypeDef) -> &mut Self {
        self.aliases.insert(name.into(), target);
        self
    }

    /// Add a union definition.
    ///
    /// Unions are untagged - all variants occupy the same memory location.
    /// This is used for Rust `#[repr(C)]` unions.
    ///
    /// # Example
    ///
    /// ```
    /// use rkyv_js_codegen::{CodeGenerator, TypeDef, UnionVariant};
    ///
    /// let mut gen = CodeGenerator::new();
    /// gen.add_union("NumberUnion", &[
    ///     UnionVariant::new("as_u32", TypeDef::U32),
    ///     UnionVariant::new("as_f32", TypeDef::F32),
    ///     UnionVariant::new("as_bytes", TypeDef::Array(Box::new(TypeDef::U8), 4)),
    /// ]);
    /// ```
    pub fn add_union(&mut self, name: impl Into<String>, variants: &[UnionVariant]) -> &mut Self {
        self.unions.insert(name.into(), variants.to_vec());
        self
    }

    /// Generate the TypeScript code as a string.
    pub fn generate(&self) -> String {
        let mut output = String::new();

        // Header
        if let Some(header) = &self.header {
            output.push_str("/**\n");
            for line in header.lines() {
                output.push_str(" * ");
                output.push_str(line);
                output.push('\n');
            }
            output.push_str(" */\n\n");
        } else {
            output.push_str("/**\n");
            output.push_str(" * Auto-generated by rkyv-js-codegen\n");
            output.push_str(" * DO NOT EDIT MANUALLY\n");
            output.push_str(" */\n\n");
        }

        // Imports
        output.push_str(&self.generate_imports());
        output.push_str("\n\n");

        // Get topologically sorted order for types
        let sorted_types = self.topological_sort();

        // Generate types in dependency order
        for type_name in &sorted_types {
            if let Some(target) = self.aliases.get(type_name) {
                output.push_str(&self.generate_alias(type_name, target));
                output.push_str("\n\n");
            } else if let Some(fields) = self.structs.get(type_name) {
                output.push_str(&self.generate_struct(type_name, fields));
                output.push_str("\n\n");
            } else if let Some(variants) = self.enums.get(type_name) {
                output.push_str(&self.generate_enum(type_name, variants));
                output.push_str("\n\n");
            } else if let Some(variants) = self.unions.get(type_name) {
                output.push_str(&self.generate_union(type_name, variants));
                output.push_str("\n\n");
            }
        }

        output.trim_end().to_string() + "\n"
    }

    /// Perform topological sort to order types by dependencies.
    /// Types that are depended upon come first.
    fn topological_sort(&self) -> Vec<String> {
        // Build dependency graph
        let mut deps: HashMap<String, HashSet<String>> = HashMap::new();
        let mut all_types: HashSet<String> = HashSet::new();

        // Collect all type names
        for name in self.structs.keys() {
            all_types.insert(name.clone());
        }
        for name in self.enums.keys() {
            all_types.insert(name.clone());
        }
        for name in self.unions.keys() {
            all_types.insert(name.clone());
        }
        for name in self.aliases.keys() {
            all_types.insert(name.clone());
        }

        // Build dependencies for structs
        for (name, fields) in &self.structs {
            let type_deps = deps.entry(name.clone()).or_default();
            for (_, ty) in fields {
                self.collect_named_deps(ty, type_deps);
            }
            // Only keep deps that are in our type set
            type_deps.retain(|d| all_types.contains(d));
        }

        // Build dependencies for enums
        for (name, variants) in &self.enums {
            let type_deps = deps.entry(name.clone()).or_default();
            for variant in variants {
                match variant {
                    EnumVariant::Unit(_) => {}
                    EnumVariant::Tuple(_, types) => {
                        for ty in types {
                            self.collect_named_deps(ty, type_deps);
                        }
                    }
                    EnumVariant::Struct(_, fields) => {
                        for (_, ty) in fields {
                            self.collect_named_deps(ty, type_deps);
                        }
                    }
                }
            }
            type_deps.retain(|d| all_types.contains(d));
        }

        // Build dependencies for unions
        for (name, variants) in &self.unions {
            let type_deps = deps.entry(name.clone()).or_default();
            for variant in variants {
                self.collect_named_deps(&variant.ty, type_deps);
            }
            type_deps.retain(|d| all_types.contains(d));
        }

        // Build dependencies for aliases
        for (name, ty) in &self.aliases {
            let type_deps = deps.entry(name.clone()).or_default();
            self.collect_named_deps(ty, type_deps);
            type_deps.retain(|d| all_types.contains(d));
        }

        // Kahn's algorithm for topological sort
        let mut in_degree: HashMap<String, usize> = HashMap::new();
        for name in &all_types {
            in_degree.insert(name.clone(), 0);
        }
        for type_deps in deps.values() {
            for dep in type_deps {
                *in_degree.get_mut(dep).unwrap() += 1;
            }
        }

        // Note: We need types with NO dependents first (leaf types)
        // So we reverse the usual topological sort logic
        let mut result = Vec::new();
        let mut queue: Vec<String> = all_types
            .iter()
            .filter(|n| deps.get(*n).map(|d| d.is_empty()).unwrap_or(true))
            .cloned()
            .collect();
        queue.sort(); // Deterministic ordering

        let mut visited = HashSet::new();
        while let Some(name) = queue.pop() {
            if visited.contains(&name) {
                continue;
            }
            visited.insert(name.clone());
            result.push(name.clone());

            // Find types that depend on this one
            for (other, other_deps) in &deps {
                if other_deps.contains(&name) && !visited.contains(other) {
                    // Check if all dependencies are satisfied
                    let all_deps_met = other_deps.iter().all(|d| visited.contains(d));
                    if all_deps_met {
                        queue.push(other.clone());
                    }
                }
            }
            queue.sort();
            queue.reverse(); // Process in reverse alphabetical for determinism
        }

        // Add any remaining types (handles cycles)
        for name in &all_types {
            if !visited.contains(name) {
                result.push(name.clone());
            }
        }

        result
    }

    fn collect_named_deps(&self, ty: &TypeDef, deps: &mut HashSet<String>) {
        match ty {
            TypeDef::Named(name) => {
                deps.insert(name.clone());
            }
            TypeDef::Vec(inner)
            | TypeDef::Option(inner)
            | TypeDef::Box(inner)
            | TypeDef::Array(inner, _) => {
                self.collect_named_deps(inner, deps);
            }
            TypeDef::Tuple(elements) => {
                for elem in elements {
                    self.collect_named_deps(elem, deps);
                }
            }
            TypeDef::HashMap(k, v) | TypeDef::BTreeMap(k, v) => {
                self.collect_named_deps(k, deps);
                self.collect_named_deps(v, deps);
            }
            _ => {}
        }
    }

    /// Write the generated code to a file.
    pub fn write_to_file(&self, path: impl AsRef<Path>) -> io::Result<()> {
        let code = self.generate();
        fs::write(path, code)
    }

    /// Write the generated code to a writer.
    pub fn write_to<W: Write>(&self, mut writer: W) -> io::Result<()> {
        let code = self.generate();
        writer.write_all(code.as_bytes())
    }

    fn generate_imports(&self) -> String {
        let mut imports = vec![
            // Core functions
            "access",
            "accessAt",
            "createArchive",
            "toBytes",
            "serialize",
            // Schema builders (decoder)
            "struct",
            // Schema builders (encoder)
            "structEncoder",
        ];

        // Check what primitive types are used
        let mut used_types = std::collections::HashSet::new();
        self.collect_used_types(&mut used_types);

        // Primitive decoder imports
        let primitive_decoders: Vec<_> = [
            ("u8", "U8"),
            ("i8", "I8"),
            ("u16", "U16"),
            ("i16", "I16"),
            ("u32", "U32"),
            ("i32", "I32"),
            ("u64", "U64"),
            ("i64", "I64"),
            ("f32", "F32"),
            ("f64", "F64"),
            ("bool", "Bool"),
            ("char", "Char"),
            ("unit", "Unit"),
            ("string", "String"),
        ]
        .iter()
        .filter(|(_, rust_name)| used_types.contains(*rust_name))
        .map(|(ts_name, _)| *ts_name)
        .collect();

        imports.extend(primitive_decoders.clone());

        // Primitive encoder imports
        let primitive_encoders: Vec<_> = [
            ("u8Encoder", "U8"),
            ("i8Encoder", "I8"),
            ("u16Encoder", "U16"),
            ("i16Encoder", "I16"),
            ("u32Encoder", "U32"),
            ("i32Encoder", "I32"),
            ("u64Encoder", "U64"),
            ("i64Encoder", "I64"),
            ("f32Encoder", "F32"),
            ("f64Encoder", "F64"),
            ("boolEncoder", "Bool"),
            ("charEncoder", "Char"),
            ("unitEncoder", "Unit"),
            ("stringEncoder", "String"),
        ]
        .iter()
        .filter(|(_, rust_name)| used_types.contains(*rust_name))
        .map(|(ts_name, _)| *ts_name)
        .collect();

        imports.extend(primitive_encoders);

        // Container decoder imports
        if used_types.contains("Vec") {
            imports.push("vec");
        }
        if used_types.contains("Option") {
            imports.push("option");
        }
        if used_types.contains("Box") {
            imports.push("box_ as box");
        }
        if used_types.contains("Array") {
            imports.push("array");
        }
        if used_types.contains("Tuple") {
            imports.push("tuple");
        }
        if used_types.contains("HashMap") || used_types.contains("BTreeMap") {
            imports.push("hashMap");
        }

        // Container encoder imports
        if used_types.contains("Vec") {
            imports.push("vecEncoder");
        }
        if used_types.contains("Option") {
            imports.push("optionEncoder");
        }
        if used_types.contains("Box") {
            imports.push("boxEncoder");
        }
        if used_types.contains("Array") {
            imports.push("arrayEncoder");
        }
        if used_types.contains("Tuple") {
            imports.push("tupleEncoder");
        }
        // Note: hashMapEncoder not yet implemented in TS, skip for now

        // Add enumType if we have enums
        if !self.enums.is_empty() {
            imports.push("enumType");
            imports.push("enumEncoder");
        }

        // Add union if we have unions
        if !self.unions.is_empty() {
            imports.push("union");
            imports.push("unionEncoder");
            imports.push("type UnionDecoder");
            imports.push("type UnionEncoderType");
        }

        // Add type imports
        imports.push("type RkyvDecoder");
        imports.push("type RkyvEncoder");
        imports.push("type Infer");

        format!(
            "import {{\n  {},\n}} from 'rkyv-js';",
            imports.join(",\n  ")
        )
    }

    fn collect_used_types(&self, used: &mut std::collections::HashSet<String>) {
        for fields in self.structs.values() {
            for (_, ty) in fields {
                self.collect_type_names(ty, used);
            }
        }
        for variants in self.enums.values() {
            for variant in variants {
                match variant {
                    EnumVariant::Unit(_) => {}
                    EnumVariant::Tuple(_, types) => {
                        for ty in types {
                            self.collect_type_names(ty, used);
                        }
                    }
                    EnumVariant::Struct(_, fields) => {
                        for (_, ty) in fields {
                            self.collect_type_names(ty, used);
                        }
                    }
                }
            }
        }
        for ty in self.aliases.values() {
            self.collect_type_names(ty, used);
        }
        for variants in self.unions.values() {
            for variant in variants {
                self.collect_type_names(&variant.ty, used);
            }
        }
    }

    fn collect_type_names(&self, ty: &TypeDef, used: &mut std::collections::HashSet<String>) {
        match ty {
            TypeDef::U8 => {
                used.insert("U8".to_string());
            }
            TypeDef::I8 => {
                used.insert("I8".to_string());
            }
            TypeDef::U16 => {
                used.insert("U16".to_string());
            }
            TypeDef::I16 => {
                used.insert("I16".to_string());
            }
            TypeDef::U32 => {
                used.insert("U32".to_string());
            }
            TypeDef::I32 => {
                used.insert("I32".to_string());
            }
            TypeDef::U64 => {
                used.insert("U64".to_string());
            }
            TypeDef::I64 => {
                used.insert("I64".to_string());
            }
            TypeDef::F32 => {
                used.insert("F32".to_string());
            }
            TypeDef::F64 => {
                used.insert("F64".to_string());
            }
            TypeDef::Bool => {
                used.insert("Bool".to_string());
            }
            TypeDef::Char => {
                used.insert("Char".to_string());
            }
            TypeDef::Unit => {
                used.insert("Unit".to_string());
            }
            TypeDef::String => {
                used.insert("String".to_string());
            }
            TypeDef::Vec(inner) => {
                used.insert("Vec".to_string());
                self.collect_type_names(inner, used);
            }
            TypeDef::Option(inner) => {
                used.insert("Option".to_string());
                self.collect_type_names(inner, used);
            }
            TypeDef::Box(inner) => {
                used.insert("Box".to_string());
                self.collect_type_names(inner, used);
            }
            TypeDef::Array(inner, _) => {
                used.insert("Array".to_string());
                self.collect_type_names(inner, used);
            }
            TypeDef::Tuple(elements) => {
                used.insert("Tuple".to_string());
                for elem in elements {
                    self.collect_type_names(elem, used);
                }
            }
            TypeDef::HashMap(k, v) => {
                used.insert("HashMap".to_string());
                self.collect_type_names(k, used);
                self.collect_type_names(v, used);
            }
            TypeDef::BTreeMap(k, v) => {
                used.insert("BTreeMap".to_string());
                self.collect_type_names(k, used);
                self.collect_type_names(v, used);
            }
            TypeDef::Named(_) => {}
        }
    }

    fn generate_alias(&self, name: &str, target: &TypeDef) -> String {
        format!(
            "// Type alias: {name}\nexport type {name} = {};\nexport const {name}Decoder = {};\nexport const {name}Encoder = {};",
            target.to_ts_type(),
            target.to_decoder_expr(),
            target.to_encoder_expr()
        )
    }

    fn generate_struct(&self, name: &str, fields: &[(String, TypeDef)]) -> String {
        let mut output = String::new();

        // TypeScript interface
        output.push_str(&format!("export interface {} {{\n", name));
        for (field_name, field_type) in fields {
            output.push_str(&format!("  {}: {};\n", field_name, field_type.to_ts_type()));
        }
        output.push_str("}\n\n");

        // Decoder
        output.push_str(&format!(
            "export const {}Decoder: RkyvDecoder<{}> = struct({{\n",
            name, name
        ));
        for (field_name, field_type) in fields {
            output.push_str(&format!(
                "  {}: {{ decoder: {} }},\n",
                field_name,
                field_type.to_decoder_expr()
            ));
        }
        output.push_str("});\n\n");

        // Encoder
        output.push_str(&format!(
            "export const {}Encoder: RkyvEncoder<{}> = structEncoder({{\n",
            name, name
        ));
        for (field_name, field_type) in fields {
            output.push_str(&format!(
                "  {}: {{ encoder: {} }},\n",
                field_name,
                field_type.to_encoder_expr()
            ));
        }
        output.push_str("});");

        output
    }

    fn generate_enum(&self, name: &str, variants: &[EnumVariant]) -> String {
        let mut output = String::new();

        // Generate variant value types
        let mut variant_types = Vec::new();
        for variant in variants {
            match variant {
                EnumVariant::Unit(vname) => {
                    variant_types.push(format!("  {}: undefined", vname));
                }
                EnumVariant::Tuple(vname, types) => {
                    // For tuple variants, use numbered fields
                    let fields: Vec<_> = types
                        .iter()
                        .enumerate()
                        .map(|(i, t)| format!("_{}: {}", i, t.to_ts_type()))
                        .collect();
                    variant_types.push(format!("  {}: {{ {} }}", vname, fields.join("; ")));
                }
                EnumVariant::Struct(vname, fields) => {
                    let fields: Vec<_> = fields
                        .iter()
                        .map(|(n, t)| format!("{}: {}", n, t.to_ts_type()))
                        .collect();
                    variant_types.push(format!("  {}: {{ {} }}", vname, fields.join("; ")));
                }
            }
        }

        // Variant map type
        output.push_str(&format!(
            "export type {}Variants = {{\n{};\n}};\n\n",
            name,
            variant_types.join(";\n")
        ));

        // Union type for the enum
        let union_members: Vec<_> = variants
            .iter()
            .map(|v| {
                let vname = v.name();
                match v {
                    EnumVariant::Unit(_) => format!("{{ tag: '{}'; value: undefined }}", vname),
                    _ => format!(
                        "{{ tag: '{}'; value: {}Variants['{}'] }}",
                        vname, name, vname
                    ),
                }
            })
            .collect();
        output.push_str(&format!(
            "export type {} =\n  | {};\n\n",
            name,
            union_members.join("\n  | ")
        ));

        // Decoder
        output.push_str(&format!(
            "export const {}Decoder: RkyvDecoder<{}> = enumType<{}Variants>({{\n",
            name, name, name
        ));
        for variant in variants {
            match variant {
                EnumVariant::Unit(vname) => {
                    output.push_str(&format!("  {}: {{}},\n", vname));
                }
                EnumVariant::Tuple(vname, types) => {
                    let fields: Vec<_> = types
                        .iter()
                        .enumerate()
                        .map(|(i, t)| format!("_{}: {{ decoder: {} }}", i, t.to_decoder_expr()))
                        .collect();
                    output.push_str(&format!(
                        "  {}: {{ fields: {{ {} }} }},\n",
                        vname,
                        fields.join(", ")
                    ));
                }
                EnumVariant::Struct(vname, fields) => {
                    let field_defs: Vec<_> = fields
                        .iter()
                        .map(|(n, t)| format!("{}: {{ decoder: {} }}", n, t.to_decoder_expr()))
                        .collect();
                    output.push_str(&format!(
                        "  {}: {{ fields: {{ {} }} }},\n",
                        vname,
                        field_defs.join(", ")
                    ));
                }
            }
        }
        output.push_str("});\n\n");

        // Encoder
        output.push_str(&format!(
            "export const {}Encoder: RkyvEncoder<{}> = enumEncoder<{}Variants>({{\n",
            name, name, name
        ));
        for variant in variants {
            match variant {
                EnumVariant::Unit(vname) => {
                    output.push_str(&format!("  {}: {{}},\n", vname));
                }
                EnumVariant::Tuple(vname, types) => {
                    let fields: Vec<_> = types
                        .iter()
                        .enumerate()
                        .map(|(i, t)| format!("_{}: {{ encoder: {} }}", i, t.to_encoder_expr()))
                        .collect();
                    output.push_str(&format!(
                        "  {}: {{ fields: {{ {} }} }},\n",
                        vname,
                        fields.join(", ")
                    ));
                }
                EnumVariant::Struct(vname, fields) => {
                    let field_defs: Vec<_> = fields
                        .iter()
                        .map(|(n, t)| format!("{}: {{ encoder: {} }}", n, t.to_encoder_expr()))
                        .collect();
                    output.push_str(&format!(
                        "  {}: {{ fields: {{ {} }} }},\n",
                        vname,
                        field_defs.join(", ")
                    ));
                }
            }
        }
        output.push_str("});");

        output
    }

    fn generate_union(&self, name: &str, variants: &[UnionVariant]) -> String {
        let mut output = String::new();

        // Generate the variants type (for accessing specific variants)
        output.push_str(&format!("export interface {}Variants {{\n", name));
        for variant in variants {
            output.push_str(&format!(
                "  {}: {};\n",
                variant.name,
                variant.ty.to_ts_type()
            ));
        }
        output.push_str("}\n\n");

        // Generate the union type (decoding all variants at once)
        output.push_str(&format!("export type {} = {}Variants;\n\n", name, name));

        // Generate the decoder
        output.push_str(&format!(
            "export const {}Decoder: UnionDecoder<{}Variants> = union({{\n",
            name, name
        ));
        for variant in variants {
            output.push_str(&format!(
                "  {}: {{ decoder: {} }},\n",
                variant.name,
                variant.ty.to_decoder_expr()
            ));
        }
        output.push_str("});\n\n");

        // Generate the encoder
        output.push_str(&format!(
            "export const {}Encoder: UnionEncoderType<{}Variants> = unionEncoder({{\n",
            name, name
        ));
        for variant in variants {
            output.push_str(&format!(
                "  {}: {{ encoder: {} }},\n",
                variant.name,
                variant.ty.to_encoder_expr()
            ));
        }
        output.push_str("});");

        output
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_simple_struct() {
        let mut gen = CodeGenerator::new();
        gen.add_struct("Point", &[("x", TypeDef::F64), ("y", TypeDef::F64)]);

        let code = gen.generate();
        assert!(code.contains("export interface Point"));
        assert!(code.contains("x: number"));
        assert!(code.contains("y: number"));
        assert!(code.contains("export const PointDecoder"));
    }

    #[test]
    fn test_generate_enum() {
        let mut gen = CodeGenerator::new();
        gen.add_enum(
            "Status",
            &[
                EnumVariant::Unit("Pending".to_string()),
                EnumVariant::Unit("Active".to_string()),
            ],
        );

        let code = gen.generate();
        assert!(code.contains("export type StatusVariants"));
        assert!(code.contains("export type Status ="));
        assert!(code.contains("export const StatusDecoder"));
    }

    #[test]
    fn test_generate_nested_types() {
        let mut gen = CodeGenerator::new();
        gen.add_struct(
            "Person",
            &[
                ("name", TypeDef::String),
                ("age", TypeDef::U32),
                ("scores", TypeDef::Vec(Box::new(TypeDef::U32))),
                ("email", TypeDef::Option(Box::new(TypeDef::String))),
            ],
        );

        let code = gen.generate();
        assert!(code.contains("scores: number[]"));
        assert!(code.contains("email: string | null"));
        assert!(code.contains("vec(u32)"));
        assert!(code.contains("option(string)"));
    }

    #[test]
    fn test_generate_union() {
        let mut gen = CodeGenerator::new();
        gen.add_union(
            "NumberUnion",
            &[
                UnionVariant::new("asU32", TypeDef::U32),
                UnionVariant::new("asF32", TypeDef::F32),
                UnionVariant::new("asBytes", TypeDef::Array(Box::new(TypeDef::U8), 4)),
            ],
        );

        let code = gen.generate();
        assert!(code.contains("export interface NumberUnionVariants"));
        assert!(code.contains("asU32: number"));
        assert!(code.contains("asF32: number"));
        assert!(code.contains("asBytes: number[]"));
        assert!(code.contains("export const NumberUnionDecoder: UnionDecoder"));
        assert!(code.contains("union({"));
    }
}
